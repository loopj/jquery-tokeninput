/*
 * jQuery Plugin: Tokenizing Autocomplete Text Entry
 * Version 1.6.6 merged with https://github.com/vdepizzol/jquery-tokeninput
 * and applied fix from https://github.com/loopj/jquery-tokeninput/pull/172/files
 * by Adam Ku≈õmierz (https://github.com/kusmierz/jquery-tokeninput)
 *
 * Copyright (c) 2009-2012 James Smith (http://loopj.com)
 * Licensed jointly under the GPL and MIT licenses,
 * choose which one suits your project best!
 *
 */

(function ($) {
// Default settings
var DEFAULT_SETTINGS = {
    // Search settings
    method: "GET",
    queryParam: "q",
    searchDelay: 300,
    minChars: 1,
    propertyToSearch: "name",
    jsonContainer: null,
    contentType: "json",

    // Prepopulation settings
    prePopulate: null,
    processPrePopulate: false,

    // Display settings
    hintText: "Type in a search term",
    noResultsText: "No results",
    searchingText: "Searching...",
    deleteText: "&times;",
    animateDropdown: true,
    theme: null,
    zindex: 999,
    escapeHTML: true, // NEW
    makeSortable: false, // NEW

    // Tokenization settings
    tokenLimit: null,
    tokenDelimiter: ",",
    tokenQuote: "'", // NEW
    tokenQuoteEscaped: "\\'", // NEW
    allowCustomEntry: false, // NEW
    preventDuplicates: false,

    // Output settings
    tokenValue: "id",


    // Manipulation settings
    idPrefix: "token-input-",

    // Formatters
    resultsFormatter: function(item){ return "<li>" + item[this.propertyToSearch]+ "</li>" },
    tokenFormatter: function(item) { return "<li><p>" + item[this.propertyToSearch] + "</p></li>" },
    inputValueFormatter: null,

    // Callbacks
    onResult: null,
    onAdd: null,
    onDelete: null,
    onReady: null
};

// Default classes to use when theming
var DEFAULT_CLASSES = {
    tokenList: "token-input-list",
    tokenListFocused: "token-input-focus", // NEW
    token: "token-input-token",
    tokenDelete: "token-input-delete-token",
    selectedToken: "token-input-selected-token",
    highlightedToken: "token-input-highlighted-token",
    draggedToken: "token-input-dragged-token", // NEW
    draggedClone: "token-input-dragged-clone", // NEW
    dropdown: "token-input-dropdown",
    dropdownItem: "token-input-dropdown-item",
    dropdownItem2: "token-input-dropdown-item2",
    selectedDropdownItem: "token-input-selected-dropdown-item",
    inputToken: "token-input-input-token",
    disabled: "token-input-disabled",
    insertBefore: "token-input-insert-before", // NEW
    insertAfter: "token-input-insert-after" // NEW
};

// Input box position "enum"
var POSITION = {
    BEFORE: 0,
    AFTER: 1,
    END: 2
};

// Keys "enum"
var KEY = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    ESCAPE: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46,
    NUMPAD_ENTER: 108,
    COMMA: 188
};

// Additional public (exposed) methods
var methods = {
    init: function(url_or_data_or_function, options) {
        var settings = $.extend({}, DEFAULT_SETTINGS, options || {});

        return this.each(function () {
            $(this).data("tokenInputObject", new $.TokenList(this, url_or_data_or_function, settings));
        });
    },
    clear: function() {
        this.data("tokenInputObject").clear();
        return this;
    },
    add: function(item) {
        this.data("tokenInputObject").add(item);
        return this;
    },
    remove: function(item) {
        this.data("tokenInputObject").remove(item);
        return this;
    },
    get: function() {
        return this.data("tokenInputObject").getTokens();
    },
    toggleDisabled: function(disable) {
        this.data("tokenInputObject").toggleDisabled(disable);
        return this;
   	}
}

// Expose the .tokenInput function to jQuery as a plugin
$.fn.tokenInput = function (method) {
    // Method calling and initialization logic
    if(methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else {
        return methods.init.apply(this, arguments);
    }
};

// TokenList class for each input
$.TokenList = function (input, url_or_data_or_function, settings) {
    //
    // Initialization
    //

    // Configure the data source
    if($.type(url_or_data_or_function) === "string" || $.type(url_or_data_or_function) === "function") {
        // Set the url to query against
        settings.url = url_or_data_or_function;

        // If the URL is a function, evaluate it here to do our initalization work
        var url = computeURL();

        // Make a smart guess about cross-domain if it wasn't explicitly specified
        if(settings.crossDomain === undefined && typeof url === "string") {
            if(url.indexOf("://") === -1) {
                settings.crossDomain = false;
            } else {
                settings.crossDomain = (location.href.split(/\/+/g)[1] !== url.split(/\/+/g)[1]);
            }
        }
    } else if(typeof(url_or_data_or_function) === "object") {
        // Set the local data to search through
        settings.local_data = url_or_data_or_function;
    }

    // Build class names
    if(settings.classes) {
        // Use custom class names
        settings.classes = $.extend({}, DEFAULT_CLASSES, settings.classes);
    } else if(settings.theme) {
        // Use theme-suffixed default class names
        settings.classes = {};
        $.each(DEFAULT_CLASSES, function(key, value) {
            settings.classes[key] = value + "-" + settings.theme;
        });
    } else {
        settings.classes = DEFAULT_CLASSES;
    }


    // Save the tokens
    var saved_tokens = {};

    // Keep track of the number of tokens in the list
    var token_count = 0;

    // Basic cache to save on db hits
    var cache = new $.TokenList.Cache();

    // Keep track of the timeout, old vals
    var timeout;
    var input_val;

    // Create a new text input an attach keyup events
    var input_box = $("<input type=\"text\"  autocomplete=\"off\">")
        .css({
            outline: "none"
        })
        .attr("id", settings.idPrefix + input[settings.tokenValue])
        .focus(function () {
            if (settings.disabled) {
                return false;
            } else if (settings.tokenLimit === null || settings.tokenLimit !== token_count) {
                show_dropdown_hint();
            }
            if($(input_box).is(":visible")) {
                token_list.addClass(settings.classes.tokenListFocused);
            }
        })
        .blur(function () {
            if(selected_token) {
                deselect_token($(selected_token));
            }
            token_list.removeClass(settings.classes.tokenListFocused);
            hide_dropdown();
            $(this).val("");
        })
        .bind("keyup keydown blur update", resize_input)
        .keydown(function (event) {
            var previous_token;
            var next_token;

            switch(event.keyCode) {
                case KEY.LEFT:
                case KEY.RIGHT:
                case KEY.UP:
                case KEY.DOWN:
                    if(!$(this).val()) {
                        previous_token = input_token.prev();
                        next_token = input_token.next();

                        if((previous_token.length && previous_token.get(0) === selected_token) || (next_token.length && next_token.get(0) === selected_token)) {
                            // Check if there is a previous/next token and it is selected
                            if(event.keyCode === KEY.LEFT || event.keyCode === KEY.UP) {
                                deselect_token($(selected_token), POSITION.BEFORE);
                            } else {
                                deselect_token($(selected_token), POSITION.AFTER);
                            }
                        } else if((event.keyCode === KEY.LEFT || event.keyCode === KEY.UP) && previous_token.length) {
                            if(selected_token) {
                                deselect_token($(selected_token));
                            }
                            // We are moving left, select the previous token if it exists
                            select_token($(previous_token.get(0)));
                        } else if((event.keyCode === KEY.RIGHT || event.keyCode === KEY.DOWN) && next_token.length) {
                            if(selected_token) {
                                deselect_token($(selected_token));
                            }
                            // We are moving right, select the next token if it exists
                            select_token($(next_token.get(0)));
                        }
                    } else {
                        var dropdown_item = null;

                        if(settings.allowCustomEntry == true) {

                            if(event.keyCode === KEY.DOWN || event.keyCode === KEY.RIGHT) {
                                if($(selected_dropdown_item).length) {
                                    if($(selected_dropdown_item).next().length) {
                                        dropdown_item = $(selected_dropdown_item).next();
                                    } else {
                                        deselect_dropdown_item($(selected_dropdown_item));
                                    }
                                } else {
                                    dropdown_item = $(dropdown).find('li:first-child');
                                }
                            } else if(event.keyCode === KEY.UP  || event.keyCode === KEY.LEFT) {
                                if($(selected_dropdown_item).length) {
                                    if($(selected_dropdown_item).prev().length) {
                                        dropdown_item = $(selected_dropdown_item).prev();
                                    } else {
                                        deselect_dropdown_item($(selected_dropdown_item));
                                    }
                                } else {
                                    dropdown_item = $(dropdown).find('li:last-child');
                                }
                            }

                            if(dropdown_item != null) {
                                select_dropdown_item(dropdown_item);
                            }

                        } else {

                            if(event.keyCode === KEY.DOWN || event.keyCode === KEY.RIGHT) {
                                dropdown_item = $(selected_dropdown_item).next();
                            } else {
                                dropdown_item = $(selected_dropdown_item).prev();
                            }

                            if(dropdown_item && dropdown_item.length) {
                                select_dropdown_item(dropdown_item);
                            }
                        }

                        if(event.keyCode === KEY.LEFT || event.keyCode === KEY.RIGHT) {
                            // we need to allow caret moving here
                            return true;
                        } else {
                            return false;
                        }
                    }
                    break;

                case KEY.BACKSPACE:
                    previous_token = input_token.prev();

                    if(!$(this).val().length) {
                        if(selected_token) {
                            delete_token($(selected_token));
                            hidden_input.change();
                        } else if(previous_token.length) {
                            select_token($(previous_token.get(0)));
                        }

                        return false;
                    } else if($(this).val().length === 1) {
                        hide_dropdown();
                    } else {
                        // set a timeout just long enough to let this function finish.
                        setTimeout(function(){do_search();}, 5);
                    }
                    break;

                case KEY.DELETE:
                    next_token = input_token.next();
                    if(!$(this).val().length) {
                        if(selected_token) {
                            delete_token($(selected_token));
                        } else if(next_token.length) {
                            select_token($(next_token.get(0)));
                        }
                    }

                    break;
                case KEY.TAB:
                case KEY.ENTER:
                case KEY.NUMPAD_ENTER:
                case KEY.COMMA:

                    if(event.keyCode == KEY.TAB && !$(input_box).val().length) {
                        hide_dropdown();
                        // let the browser handle the tab key properly if user is trying to tab through or out
                        return true;
                    }
                    if(selected_dropdown_item) {
                        add_token($(selected_dropdown_item).data("tokeninput"));
                        hidden_input.change();
                    }

                    if(settings.allowCustomEntry == true && $.trim($(input_box).val()) != '') {
                        add_token($(input_box).val());
                    }

                    return false;
                    break;

                case KEY.ESCAPE:
                  hide_dropdown();
                  return true;

                default:
                    if(String.fromCharCode(event.which)) {
                        // set a timeout just long enough to let this function finish.
                        setTimeout(function(){do_search();}, 5);
                    }
                    break;
            }
        });

    var unique_counter = 0;
    function get_unique_id() {
        unique_counter++;
        return 'u' + unique_counter;
    }

    // hides original input box
    // input.type = 'hidden'; // for back compability, I had to comment it

    // Keep a reference to the original input box
    var hidden_input = $(input)
                           .hide()
                           .val("")
                           .focus(function () {
                                focus_with_timeout(input_box);
                           })
                           .blur(function () {
                               input_box.blur();
                           });

    // Carry over the tab index if it's set
    input_box.attr({ tabindex: hidden_input.attr('tabindex') });

    // Keep a reference to the selected token and dropdown item
    var selected_token = null;
    var selected_token_index = 0;
    var selected_dropdown_item = null;

    // The list to store the token items in
    var token_list = $("<ul />")
        .addClass(settings.classes.tokenList + ' ' + hidden_input.attr('class'))
        .click(function (event) {
            var li = $(event.target).closest("li");
            if(li && li.get(0) && $.data(li.get(0), "tokeninput")) {
                focus_with_timeout(input_box);
                toggle_select_token(li);
            } else {
                // Deselect selected token
                if(selected_token) {
                    deselect_token($(selected_token), POSITION.END);
                }

                // Focus input box
                focus_with_timeout(input_box);
            }
        })
        .mouseover(function (event) {
            var li = $(event.target).closest("li");
            if(li && selected_token !== this) {
                li.addClass(settings.classes.highlightedToken);
            }
        })
        .mouseout(function (event) {
            var li = $(event.target).closest("li");
            if(li && selected_token !== this) {
                li.removeClass(settings.classes.highlightedToken);
            }
        })
        .insertBefore(hidden_input);

    // The token holding the input box
    var input_token = $("<li />")
        .addClass(settings.classes.inputToken)
        .appendTo(token_list)
        .append(input_box);

    // The list to store the dropdown items in
    var dropdown = $("<div>")
        .addClass(settings.classes.dropdown)
        .appendTo("body")
        .hide();

    // Magic element to help us resize the text input
    var input_resizer = $("<tester/>")
        .insertAfter(input_box)
        .css({
            position: "absolute",
            top: -9999,
            left: -9999,
            width: "auto",
            fontSize: input_box.css("fontSize"),
            fontFamily: input_box.css("fontFamily"),
            fontWeight: input_box.css("fontWeight"),
            letterSpacing: input_box.css("letterSpacing"),
            whiteSpace: "nowrap"
        });

    // True during dragging process
    var dragging = false;

    var dragTimeout;

    // the dragged Token
    var dragToken;

    // the destination Token
    var dragDestination;

    // Pre-populate list if items exist
    hidden_input.val("");
    var li_data = settings.prePopulate || hidden_input.data("pre");
    if(settings.processPrePopulate && $.isFunction(settings.onResult)) {
        li_data = settings.onResult.call(hidden_input, li_data);
    }
    if(li_data && li_data.length) {
        $.each(li_data, function (index, value) {
            insert_token(value);
            checkTokenLimit();
        });
    }

    // Check if widget should initialize as disabled
    if (settings.disabled) {
        toggleDisabled(true);
    }

    // Initialization is done
    if($.isFunction(settings.onReady)) {
        settings.onReady.call();
    }

    //
    // Public functions
    //

    this.clear = function() {
        token_list.children("li").each(function() {
            if ($(this).children("input").length === 0) {
                delete_token($(this));
            }
        });
    }

    this.add = function(item) {
        add_token(item);
    }

    this.remove = function(item) {
        token_list.children("li[data-uniqueid]").each(function() {
            if ($(this).children("input").length === 0) {
                var currToken = $(this).data("tokeninput");
                var match = true;
                for (var prop in item) {
                    if (item[prop] !== currToken[prop]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    delete_token($(this));
                }
            }
        });
    }

    this.getTokens = function() {
   		return saved_tokens;
   	}

    this.toggleDisabled = function(disable) {
        toggleDisabled(disable);
    }

    //
    // Private functions
    //

    // Toggles the widget between enabled and disabled state, or according
    // to the [disable] parameter.
    function toggleDisabled(disable) {
        if (typeof disable === 'boolean') {
          settings.disabled = disable
        } else {
            settings.disabled = !settings.disabled;
        }
        input_box.prop('disabled', settings.disabled);
        token_list.toggleClass(settings.classes.disabled, settings.disabled);
        // if there is any token selected we deselect it
        if(selected_token) {
            deselect_token($(selected_token), POSITION.END);
        }
        hidden_input.prop('disabled', settings.disabled);
    }

    function checkTokenLimit() {
        if(settings.tokenLimit !== null && token_count >= settings.tokenLimit) {
            input_box.hide();
            hide_dropdown();
            return;
        }
    }

    function resize_input() {
        if(input_val === (input_val = input_box.val())) {return;}

        // Enter new content into resizer and resize input accordingly
        var escaped = input_val.replace(/&/g, '&amp;').replace(/\s/g,' ').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        input_resizer.html(escaped);
        input_box.width(input_resizer.width() + 30);
    }

    function is_printable_character(keycode) {
        return ((keycode >= 48 && keycode <= 90) ||     // 0-1a-z
                (keycode >= 96 && keycode <= 111) ||    // numpad 0-9 + - / * .
                (keycode >= 186 && keycode <= 192) ||   // ; = , - . / ^
                (keycode >= 219 && keycode <= 222));    // ( \ ) '
    }

    // Inner function to a token to the list
    function insert_token(item) {
        var uniqueid = get_unique_id();

        var this_token = settings.tokenFormatter(item);
        this_token = $(this_token)
          .addClass(settings.classes.token)
          .insertBefore(input_token)
          .attr('data-uniqueid', uniqueid);


        if(settings.makeSortable) {
            addDragFunctionality(this_token);
        };


        // The 'delete token' button
        $("<span>" + settings.deleteText + "</span>")
            .addClass(settings.classes.tokenDelete)
            .appendTo(this_token)
            .click(function () {
                if (!settings.disabled) {
                    delete_token($(this).parent());
                    hidden_input.change();
                    return false;
                }
                delete_token($(this).parent());
                hidden_input.change();
                return false;
            });

        // Store data on the token
        var token_data = item;
        $.data(this_token.get(0), "tokeninput", item);

        // Save this token for duplicate checking
        // saved_tokens = saved_tokens.slice(0,selected_token_index).concat([token_data]).concat(saved_tokens.slice(selected_token_index));
        saved_tokens[uniqueid] = token_data;
        selected_token_index++;

        // Update the hidden input
        update_hidden_input(saved_tokens, hidden_input);
        token_count += 1;

        // Check the token limit
        checkTokenLimit();

        return this_token;
    }

    // Add a token to the token list based on user input
    function add_token (item) {

        if(typeof(item) === "string") {
            var li_data = {name: item};
        } else if(item[0]) {
            var li_data = $.data(item.get(0), "tokeninput");
        } else {
            var li_data = item;
        }

        if(!li_data) {
            return false;
        }

        var callback = settings.onAdd;

        // See if the token already exists and select it if we don't want duplicates
        if(token_count > 0 && settings.preventDuplicates) {
            var found_existing_token = null;
            token_list.children().each(function () {
                var existing_token = $(this);
                var existing_data = $.data(existing_token.get(0), "tokeninput");
                if(existing_data &&
                    ((existing_data[settings.tokenValue] && existing_data[settings.tokenValue] === item[settings.tokenValue]) ||
                    (!existing_data[settings.tokenValue] && existing_data[settings.propertyToSearch] === li_data[settings.propertyToSearch]))
                ) {
                    found_existing_token = existing_token;
                    return false;
                }
            });

            if(found_existing_token) {
                select_token(found_existing_token);
                input_token.insertAfter(found_existing_token);
                focus_with_timeout(input_box);
                return;
            }
        }

        // Insert the new tokens
        if(settings.tokenLimit == null || token_count < settings.tokenLimit) {
            insert_token(li_data);
            checkTokenLimit();
        }

        // Clear input box
        input_box.val("");

        // Don't show the help dropdown, they've got the idea
        hide_dropdown();

        // Execute the onAdd callback if defined
        if($.isFunction(callback)) {
            callback.call(hidden_input,li_data);
        }
    }

    //
    //  Drag and Drop  Functionality
    //
    function addDragFunctionality(token) {
        token.bind('mousedown', function() {
            var token = $(this);

            dragToken = token;

            dragTimeout = window.setTimeout(function(e) {

                if(selected_token == token) {
                    return;
                }

                if(selected_token) {
                    deselect_token($(selected_token), POSITION.END);
                }

                select_token(token);

                var position = $(token).position();

                $(token).clone().appendTo('body').addClass(settings.classes.draggedClone).css({'top': position.top, 'left': position.left});
                token.addClass(settings.classes.draggedToken);

                dragging = true;

            }, 200);

            $(document).one('mouseup', function() {

                window.clearTimeout(dragTimeout);

                if(dragging != true) {
                    return;
                }

                dragging = false;

                $('li.'+settings.classes.draggedClone).remove();
                $('li.'+settings.classes.draggedToken).removeClass(settings.classes.draggedToken);

                if(selected_token) {
                    deselect_token($(selected_token), POSITION.END);
                }

                if(dragDestination) {
                    move_token(token, dragDestination);
                    reindex_results();
                }
            });

            return false;
        })
            .bind('mouseover', function() {

                if(!dragging) return;

                dragDestination = $(this);

                if(is_after(dragToken, dragDestination)) {
                    dragDestination.addClass(settings.classes.insertAfter);
                } else {
                    dragDestination.addClass(settings.classes.insertBefore);
                }
            })
            .bind('mouseout', function() {

                if(!dragging) return;

                $(this).removeClass(settings.classes.insertBefore);
                $(this).removeClass(settings.classes.insertAfter);
            }).
            bind('mouseup', function(){
                $(this).removeClass(settings.classes.insertBefore);
                $(this).removeClass(settings.classes.insertAfter);
            });

        $('body').mousemove(function(e) {
            if(!dragging) return;

            $('li.'+settings.classes.draggedClone).css({'top': e.pageY, 'left': e.pageX});
        });
    }


    function move_token(token, destinationToken) {
        if(!destinationToken || token.get(0) == destinationToken.get(0)) return;

        if(is_after(token, destinationToken)) {
            token.insertAfter(destinationToken);
        } else {
            token.insertBefore(destinationToken);
        }
    }

    function is_after(first, last) {
        index_tokens();
        first = $.data(first.get(0), "tokeninput");
        last = $.data(last.get(0), "tokeninput");
        if(!first || !last) return;
        return last.index > first.index
    }


    function index_tokens() {
        var i = 0;
        token_list.find('li').each(function() {
            var data = $.data(this, "tokeninput");
            if(data) {
                data.index = i;
            }
            i++;
        });
    }

    function reindex_results() {
        var ids = [], tokens = [];
        token_list.find('li').each(function() {
            var data = $.data(this, "tokeninput");
            if(data) {
                ids.push(data[settings.tokenValue]);
                tokens.push(data);
            };
        });
        saved_tokens = tokens;
        update_hidden_input(saved_tokens, hidden_input);
    }


    // end Drag and Drop Functionality

    // Select a token in the token list
    function select_token (token) {
        if (!settings.disabled) {
            token.addClass(settings.classes.selectedToken);
            selected_token = token.get(0);

            // Hide input box
            input_box.val("").css('color', 'transparent');
        }
        // Hide dropdown if it is visible (eg if we clicked to select token)
        hide_dropdown();
    }

    // Deselect a token in the token list
    function deselect_token (token, position) {
        token.removeClass(settings.classes.selectedToken);
        selected_token = null;

        input_box.css('color', '');

        if(position === POSITION.BEFORE) {
            input_token.insertBefore(token);
            selected_token_index--;
        } else if(position === POSITION.AFTER) {
            input_token.insertAfter(token);
            selected_token_index++;
        } else {
            input_token.appendTo(token_list);
            selected_token_index = token_count;
        }

        // Show the input box and give it focus again
        focus_with_timeout(input_box);
    }

    // Toggle selection of a token in the token list
    function toggle_select_token(token) {
        var previous_selected_token = selected_token;

        if(selected_token) {
            deselect_token($(selected_token), POSITION.END);
        }

        if(previous_selected_token === token.get(0)) {
            deselect_token(token, POSITION.END);
        } else {
            select_token(token);
        }
    }

    // Delete a token from the token list
    function delete_token (token) {
        // Remove the id from the saved list
        var token_data = $.data(token.get(0), "tokeninput");
        var callback = settings.onDelete;

        var index = token.prevAll().length;
        if(index > selected_token_index) index--;

        var uniqueid = $(token).attr('data-uniqueid');

        // Delete the token
        token.remove();
        selected_token = null;

        // Show the input box and give it focus again
        focus_with_timeout(input_box);
        input_box.css('color', '');

        // Remove this token from the saved list
        delete saved_tokens[uniqueid];

        if(index < selected_token_index) selected_token_index--;

        // Update the hidden input
        update_hidden_input(saved_tokens, hidden_input);

        token_count -= 1;

        if(settings.tokenLimit !== null) {
            input_box
                .show()
                .val("");
            focus_with_timeout(input_box);
        }

        // Execute the onDelete callback if defined
        if($.isFunction(callback)) {
            callback.call(hidden_input,token_data);
        }
    }

    function format_tokens(tokens) {
        var token_ids = [];
        var regex = new RegExp(settings.tokenQuote, "gi");
        $.each(tokens, function (index, value) {
            token_ids.push(value[settings.tokenValue]
                ? value[settings.tokenValue]
                : settings.tokenQuote + value[settings.propertyToSearch].replace(regex, settings.tokenQuoteEscaped) + settings.tokenQuote
            );
        });
        return token_ids.join(settings.tokenDelimiter);
    }

    // Update the hidden input box value
    function update_hidden_input(saved_tokens, hidden_input) {
        var formatter = settings.inputValueFormatter || format_tokens;
        hidden_input.val(formatter(saved_tokens));
    }

    // Hide and clear the results dropdown
    function hide_dropdown () {
        dropdown.hide().empty();
        selected_dropdown_item = null;
    }

    function show_dropdown() {
        dropdown
            .css({
                position: "absolute",
                top: $(token_list).offset().top + $(token_list).outerHeight(),
                left: $(token_list).offset().left,
                'z-index': settings.zindex,
                zindex: settings.zindex,
                width: $(token_list).outerWidth()
            })
            .show();
    }

    function show_dropdown_searching () {
        if(settings.searchingText) {
            dropdown.html("<p>"+settings.searchingText+"</p>");
            show_dropdown();
        }
    }

    function show_dropdown_hint () {
        if(settings.hintText) {
            dropdown.html("<p>"+settings.hintText+"</p>");
            show_dropdown();
        }
    }

    // Highlight the query part of the search term
    // from http://www.alistapart.com/articles/accent-folding-for-auto-complete/
    function highlight_term(str, q) {
        str = str.toString();
        var q_folded = q.toString().removeDiacritics().toLowerCase().preg_quote().sql_regcase(); // make kind of regexp

        // create an intermediary string with hilite hints
        // example: fulani<lo> <lo>pez
        var re = new RegExp("(" + q_folded + ")", "gi");
        //  return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<b>$1</b>");
        var highlighted = str.replace(re, '<b>$1</b>');

        return highlighted;
    }

    function find_value_and_highlight_term(template, value, term) {
        // return template.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + value.preg_quote() + ")(?![^<>]*>)(?![^&;]+;)", "g"), highlight_term(value, term));
        return template.replace(new RegExp("(" + value.preg_quote() + ")", "g"), highlight_term(value, term));
    }

    // Populate the results dropdown with some results
    function populate_dropdown (query, results) {
        if(results && results.length) {
            dropdown.empty();
            var dropdown_ul = $("<ul>")
                .appendTo(dropdown)
                .mouseover(function (event) {
                    select_dropdown_item($(event.target).closest("li"));
                })
                .mousedown(function (event) {
                    add_token($(event.target).closest("li").data("tokeninput"));
                    hidden_input.change();
                    return false;
                })
                .hide();

            $.each(results, function(index, value) {

                var this_li = settings.resultsFormatter(value);

                this_li = find_value_and_highlight_term(this_li ,value[settings.propertyToSearch], query);

                this_li = $(this_li).appendTo(dropdown_ul);

                if(index % 2) {
                    this_li.addClass(settings.classes.dropdownItem);
                } else {
                    this_li.addClass(settings.classes.dropdownItem2);
                }

                if(settings.allowCustomEntry == false) {
                    if(index === 0) {
                        select_dropdown_item(this_li);
                    }
                }

                $.data(this_li.get(0), "tokeninput", value);
            });

            show_dropdown();

            if(settings.animateDropdown) {
                dropdown_ul.slideDown("fast");
            } else {
                dropdown_ul.show();
            }
        } else {
            if(settings.noResultsText && !settings.allowCustomEntry) {
                dropdown.html("<p>"+settings.noResultsText+"</p>");
                show_dropdown();
            } else {
                hide_dropdown();
            }
        }
    }

    // Highlight an item in the results dropdown
    function select_dropdown_item (item) {
        if(item) {
            if(selected_dropdown_item) {
                deselect_dropdown_item($(selected_dropdown_item));
            }

            item.addClass(settings.classes.selectedDropdownItem);
            selected_dropdown_item = item.get(0);
        }
    }

    // Remove highlighting from an item in the results dropdown
    function deselect_dropdown_item (item) {
        item.removeClass(settings.classes.selectedDropdownItem);
        selected_dropdown_item = null;
    }

    function escapeHTML(text) {
        if(!settings.escapeHTML) return text;
        return $("<p></p>").text(text).html();
    }

    // Do a search and show the "searching" dropdown if the input is longer
    // than settings.minChars
    function do_search() {
        var query = input_box.val().toLowerCase();

        checkTokenLimit();

        if(query && query.length) {
            if(selected_token) {
                deselect_token($(selected_token), POSITION.AFTER);
            }

            if(query.length >= settings.minChars) {
                show_dropdown_searching();
                clearTimeout(timeout);

                timeout = setTimeout(function(){
                    run_search(query);
                }, settings.searchDelay);
            } else {
                hide_dropdown();
            }
        }
    }

    // Do the actual search
    function run_search(query) {
        var cache_key = query + computeURL();
        var cached_results = cache.get(cache_key);
        if(cached_results) {
            populate_dropdown(query, cached_results);
        } else {
            // Are we doing an ajax search or local data search?
            if(settings.url) {
                var url = computeURL();
                // Extract exisiting get params
                var ajax_params = {};
                ajax_params.data = {};
                if(url.indexOf("?") > -1) {
                    var parts = url.split("?");
                    ajax_params.url = parts[0];

                    var param_array = parts[1].split("&");
                    $.each(param_array, function (index, value) {
                        var kv = value.split("=");
                        ajax_params.data[kv[0]] = kv[1];
                    });
                } else {
                    ajax_params.url = url;
                }

                // Prepare the request
                ajax_params.data[settings.queryParam] = query;
                ajax_params.type = settings.method;
                ajax_params.dataType = settings.contentType;
                if(settings.crossDomain) {
                    ajax_params.dataType = "jsonp";
                }

                // Attach the success callback
                ajax_params.success = function(results) {
                  if($.isFunction(settings.onResult)) {
                      results = settings.onResult.call(hidden_input, results);
                  }
                  cache.add(cache_key, settings.jsonContainer ? results[settings.jsonContainer] : results);

                  // only populate the dropdown if the results are associated with the active search query
                  if(input_box.val().toLowerCase() === query) {
                      populate_dropdown(query, settings.jsonContainer ? results[settings.jsonContainer] : results);
                  }
                };

                // Make the request
                $.ajax(ajax_params);
            } else if(settings.local_data) {
                // Do the search through local data
                var results = $.grep(settings.local_data, function (row) {
                    var founded = false;
                    return row[settings.propertyToSearch].toString().toLowerCase().removeDiacritics().indexOf(query.toString().toLowerCase().removeDiacritics()) > -1;
                });

                if($.isFunction(settings.onResult)) {
                    results = settings.onResult.call(hidden_input, results);
                }
                cache.add(cache_key, results);
                populate_dropdown(query, results);
            }
        }
    }

    // compute the dynamic URL
    function computeURL() {
        var url = settings.url;
        if(typeof settings.url == 'function') {
            url = settings.url.call(settings);
        }
        return url;
    }
};

// works almost as php equivalent
String.prototype.sql_regcase = function() {
    var str = this;

    var reversedAccentMap = {
        '0': ['Ôºê'],
        '1': ['Ôºë'],
        '2': ['Ôºí'],
        '3': ['Ôºì'],
        '4': ['Ôºî'],
        '5': ['Ôºï'],
        '6': ['Ôºñ'],
        '7': ['Ôºó'],
        '8': ['Ôºò'],
        '9': ['Ôºô'],
        'a': ['·∫ö', '√Å', '√°', '√Ä', '√†', 'ƒÇ', 'ƒÉ', '·∫Æ', '·∫Ø', '·∫∞', '·∫±', '·∫¥', '·∫µ', '·∫≤', '·∫≥', '√Ç', '√¢', '·∫§', '·∫•', '·∫¶', '·∫ß', '·∫™', '·∫´', '·∫®', '·∫©', '«ç', '«é', '√Ö', '√•', '«∫', '«ª', '√Ñ', '√§', '«û', '«ü', '√É', '√£', '»¶', '»ß', '«†', '«°', 'ƒÑ', 'ƒÖ', 'ƒÄ', 'ƒÅ', '·∫¢', '·∫£', '»Ä', '»Å', '»Ç', '»É', '·∫†', '·∫°', '·∫∂', '·∫∑', '·∫¨', '·∫≠', '·∏Ä', '·∏Å', '»∫', '‚±•', '«º', '«Ω', '«¢', '«£', 'ƒπ', 'ÔΩÅ'],
        'b': ['·∏Ç', '·∏É', '·∏Ñ', '·∏Ö', '·∏Ü', '·∏á', '…É', '∆Ä', '·µ¨', '∆Å', '…ì', '∆Ç', '∆É', 'ÔΩÇ'],
        'c': ['ƒÜ', 'ƒá', 'ƒà', 'ƒâ', 'ƒå', 'ƒç', 'ƒä', 'ƒã', '√á', '√ß', '·∏à', '·∏â', '»ª', '»º', '∆á', '∆à', '…ï', 'ÔΩÉ'],
        'd': ['ƒé', 'ƒè', '·∏ä', '·∏ã', '·∏ê', '·∏ë', '·∏å', '·∏ç', '·∏í', '·∏ì', '·∏é', '·∏è', 'ƒê', 'ƒë', '·µ≠', '∆â', '…ñ', '∆ä', '…ó', '∆ã', '∆å', '»°', '√∞', 'ÔΩÑ'],
        'e': ['√â', '∆è', '∆é', '«ù', '√©', '√à', '√®', 'ƒî', 'ƒï', '√ä', '√™', '·∫æ', '·∫ø', '·ªÄ', '·ªÅ', '·ªÑ', '·ªÖ', '·ªÇ', '·ªÉ', 'ƒö', 'ƒõ', '√ã', '√´', '·∫º', '·∫Ω', 'ƒñ', 'ƒó', '»®', '»©', '·∏ú', '·∏ù', 'ƒò', 'ƒô', 'ƒí', 'ƒì', '·∏ñ', '·∏ó', '·∏î', '·∏ï', '·∫∫', '·∫ª', '»Ñ', '»Ö', '»Ü', '»á', '·∫∏', '·∫π', '·ªÜ', '·ªá', '·∏ò', '·∏ô', '·∏ö', '·∏õ', '…Ü', '…á', '…ö', '…ù', 'ÔΩÖ'],
        'f': ['·∏û', '·∏ü', '·µÆ', '∆ë', '∆í', 'ÔΩÜ'],
        'g': ['«¥', '«µ', 'ƒû', 'ƒü', 'ƒú', 'ƒù', '«¶', '«ß', 'ƒ†', 'ƒ°', 'ƒ¢', 'ƒ£', '·∏†', '·∏°', '«§', '«•', '∆ì', '…†', 'ÔΩá'],
        'h': ['ƒ§', 'ƒ•', '»û', '»ü', '·∏¶', '·∏ß', '·∏¢', '·∏£', '·∏®', '·∏©', '·∏§', '·∏•', '·∏™', '·∏´', 'H', 'Ã±', '·∫ñ', 'ƒ¶', 'ƒß', '‚±ß', '‚±®', 'ÔΩà'],
        'i': ['√ç', '√≠', '√å', '√¨', 'ƒ¨', 'ƒ≠', '√é', '√Æ', '«è', '«ê', '√è', '√Ø', '·∏Æ', '·∏Ø', 'ƒ®', 'ƒ©', 'ƒ∞', 'i', 'ƒÆ', 'ƒØ', 'ƒ™', 'ƒ´', '·ªà', '·ªâ', '»à', '»â', '»ä', '»ã', '·ªä', '·ªã', '·∏¨', '·∏≠', 'I', 'ƒ±', '∆ó', '…®', 'ÔΩâ'],
        'j': ['ƒ¥', 'ƒµ', 'J', 'Ãå', '«∞', '»∑', '…à', '…â', ' ù', '…ü', ' Ñ', 'ÔΩä'],
        'k': ['·∏∞', '·∏±', '«®', '«©', 'ƒ∂', 'ƒ∑', '·∏≤', '·∏≥', '·∏¥', '·∏µ', '∆ò', '∆ô', '‚±©', '‚±™', 'ÔΩã'],
        'l': ['ƒ∫', 'ƒΩ', 'ƒæ', 'ƒª', 'ƒº', '·∏∂', '·∏∑', '·∏∏', '·∏π', '·∏º', '·∏Ω', '·∏∫', '·∏ª', '≈Å', '≈Ç', 'Ã£', 'ƒø', '≈Ä', '»Ω', '∆ö', '‚±†', '‚±°', '‚±¢', '…´', '…¨', '…≠', '»¥', 'ÔΩå'],
        'm': ['·∏æ', '·∏ø', '·πÄ', '·πÅ', '·πÇ', '·πÉ', '…±', 'ÔΩç'],
        'n': ['≈É', '≈Ñ', '«∏', '«π', '≈á', '≈à', '√ë', '√±', '·πÑ', '·πÖ', '≈Ö', '≈Ü', '·πÜ', '·πá', '·πä', '·πã', '·πà', '·πâ', '∆ù', '…≤', '»†', '∆û', '…≥', '»µ', 'N', 'n', 'ÔΩé'],
        't': ['Ãà', '√û', '√æ', '≈§', '≈•', 'T', '·∫ó', '·π™', '·π´', '≈¢', '≈£', '·π¨', '·π≠', '»ö', '»õ', '·π∞', '·π±', '·πÆ', '·πØ', '≈¶', '≈ß', '»æ', '‚±¶', '·µµ', '∆´', '∆¨', '∆≠', '∆Æ', ' à', '»∂', 'ÔΩî'],
        'o': ['√ì', '√≥', '√í', '√≤', '≈é', '≈è', '√î', '√¥', '·ªê', '·ªë', '·ªí', '·ªì', '·ªñ', '·ªó', '·ªî', '·ªï', '«ë', '«í', '√ñ', '√∂', '»™', '»´', '≈ê', '≈ë', '√ï', '√µ', '·πå', '·πç', '·πé', '·πè', '»¨', '»≠', '»Æ', '»Ø', '»∞', '»±', '√ò', '√∏', '«æ', '«ø', '«™', '«´', '«¨', '«≠', '≈å', '≈ç', '·πí', '·πì', '·πê', '·πë', '·ªé', '·ªè', '»å', '»ç', '»é', '»è', '∆†', '∆°', '·ªö', '·ªõ', '·ªú', '·ªù', '·ª†', '·ª°', '·ªû', '·ªü', '·ª¢', '·ª£', '·ªå', '·ªç', '·ªò', '·ªô', '∆ü', '…µ', 'ÔΩè'],
        'p': ['·πî', '·πï', '·πñ', '·πó', '‚±£', '∆§', '∆•', 'P', 'ÃÉ', 'p', 'ÔΩê'],
        'q': [' †', '…ä', '…ã', 'ÔΩë'],
        'r': ['≈î', '≈ï', '≈ò', '≈ô', '·πò', '·πô', '≈ñ', '≈ó', '»ê', '»ë', '»í', '»ì', '·πö', '·πõ', '·πú', '·πù', '·πû', '·πü', '…å', '…ç', '·µ≤', '…º', '‚±§', '…Ω', '…æ', '·µ≥', 'ÔΩí'],
        's': ['√ü', '≈ö', '≈õ', '·π§', '·π•', '≈ú', '≈ù', '≈†', '≈°', '·π¶', '·πß', '·π†', '·π°', '·∫õ', '≈û', '≈ü', '·π¢', '·π£', '·π®', '·π©', '»ò', '»ô', ' Ç', 'S', 'Ã©', 's', 'ÔΩì'],
        'u': ['√ö', '√∫', '√ô', '√π', '≈¨', '≈≠', '√õ', '√ª', '«ì', '«î', '≈Æ', '≈Ø', '√ú', '√º', '«ó', '«ò', '«õ', '«ú', '«ô', '«ö', '«ï', '«ñ', '≈∞', '≈±', '≈®', '≈©', '·π∏', '·ππ', '≈≤', '≈≥', '≈™', '≈´', '·π∫', '·πª', '·ª¶', '·ªß', '»î', '»ï', '»ñ', '»ó', '∆Ø', '∆∞', '·ª®', '·ª©', '·ª™', '·ª´', '·ªÆ', '·ªØ', '·ª¨', '·ª≠', '·ª∞', '·ª±', '·ª§', '·ª•', '·π≤', '·π≥', '·π∂', '·π∑', '·π¥', '·πµ', '…Ñ', ' â', 'ÔΩï'],
        'v': ['·πº', '·πΩ', '·πæ', '·πø', '∆≤', ' ã', 'ÔΩñ'],
        'w': ['·∫Ç', '·∫É', '·∫Ä', '·∫Å', '≈¥', '≈µ', 'W', '·∫ò', '·∫Ñ', '·∫Ö', '·∫Ü', '·∫á', '·∫à', '·∫â', 'ÔΩó'],
        'y': ['Ãä', '√ù', '√Ω', '·ª≤', '·ª≥', '≈∂', '≈∑', 'Y', '·∫ô', '≈∏', '√ø', '·ª∏', '·ªπ', '·∫é', '·∫è', '»≤', '»≥', '·ª∂', '·ª∑', '·ª¥', '·ªµ', ' è', '…é', '…è', '∆≥', '∆¥', 'ÔΩô'],
        'x': ['·∫å', '·∫ç', '·∫ä', '·∫ã', 'ÔΩò'],
        'z': ['≈π', '≈∫', '·∫ê', '·∫ë', '≈Ω', '≈æ', '≈ª', '≈º', '·∫í', '·∫ì', '·∫î', '·∫ï', '∆µ', '∆∂', '»§', '»•', ' ê', ' ë', '‚±´', '‚±¨', '«Æ', '«Ø', '∆∫', 'ÔΩö'],
        'B': ['Ôº¢'],
        'F': ['Ôº¶'],
        'J': ['Ôº™'],
        'N': ['ÔºÆ'],
        'R': ['Ôº≤'],
        'V': ['Ôº∂'],
        'Z': ['Ôº∫'],
        'A': ['Ôº°'],
        'E': ['Ôº•'],
        'I': ['Ôº©'],
        'M': ['Ôº≠'],
        'Q': ['Ôº±'],
        'U': ['Ôºµ'],
        'Y': ['Ôºπ'],
        'D': ['Ôº§'],
        'H': ['Ôº®'],
        'L': ['Ôº¨'],
        'P': ['Ôº∞'],
        'T': ['Ôº¥'],
        'X': ['Ôº∏'],
        'C': ['Ôº£'],
        'G': ['Ôºß'],
        'K': ['Ôº´'],
        'O': ['ÔºØ'],
        'S': ['Ôº≥'],
        'W': ['Ôº∑']
    };

    var ret = '';
    for (var i = 0; i < str.length; i++) {
        if (reversedAccentMap[str.charAt(i)]) {
            ret += '[' + str.charAt(i) + reversedAccentMap[str.charAt(i)].join('') + ']';
        } else {
            ret += str.charAt(i);
        }
    }
    return ret;
};


// Works as php's preg_quote
String.prototype.preg_quote = function(delimiter) {
    var str = this;
    return (str + '').replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&');
};

// Remove Diacritics
// @see http://www.alistapart.com/articles/accent-folding-for-auto-complete/
String.prototype.removeDiacritics = function () {

    var str = this;

    if (!str) {
        return '';
    }

    var accent_map = {
        '·∫ö':'a', '√Å':'a', '√°':'a', '√Ä':'a', '√†':'a', 'ƒÇ':'a', 'ƒÉ':'a', '·∫Æ':'a', '·∫Ø':'a', '·∫∞':'a', '·∫±':'a', '·∫¥':'a', '·∫µ':'a', '·∫≤':'a', '·∫≥':'a', '√Ç':'a', '√¢':'a', '·∫§':'a', '·∫•':'a', '·∫¶':'a', '·∫ß':'a', '·∫™':'a', '·∫´':'a', '·∫®':'a', '·∫©':'a', '«ç':'a', '«é':'a', '√Ö':'a', '√•':'a', '«∫':'a', '«ª':'a', '√Ñ':'a', '√§':'a', '«û':'a', '«ü':'a', '√É':'a', '√£':'a', '»¶':'a', '»ß':'a', '«†':'a', '«°':'a', 'ƒÑ':'a', 'ƒÖ':'a', 'ƒÄ':'a', 'ƒÅ':'a', '·∫¢':'a', '·∫£':'a', '»Ä':'a', '»Å':'a', '»Ç':'a', '»É':'a', '·∫†':'a', '·∫°':'a', '·∫∂':'a', '·∫∑':'a', '·∫¨':'a', '·∫≠':'a', '·∏Ä':'a', '·∏Å':'a', '»∫':'a', '‚±•':'a', '«º':'a', '«Ω':'a', '«¢':'a', '«£':'a',
        '·∏Ç':'b', '·∏É':'b', '·∏Ñ':'b', '·∏Ö':'b', '·∏Ü':'b', '·∏á':'b', '…É':'b', '∆Ä':'b', '·µ¨':'b', '∆Å':'b', '…ì':'b', '∆Ç':'b', '∆É':'b',
        'ƒÜ':'c', 'ƒá':'c', 'ƒà':'c', 'ƒâ':'c', 'ƒå':'c', 'ƒç':'c', 'ƒä':'c', 'ƒã':'c', '√á':'c', '√ß':'c', '·∏à':'c', '·∏â':'c', '»ª':'c', '»º':'c', '∆á':'c', '∆à':'c', '…ï':'c',
        'ƒé':'d', 'ƒè':'d', '·∏ä':'d', '·∏ã':'d', '·∏ê':'d', '·∏ë':'d', '·∏å':'d', '·∏ç':'d', '·∏í':'d', '·∏ì':'d', '·∏é':'d', '·∏è':'d', 'ƒê':'d', 'ƒë':'d', '·µ≠':'d', '∆â':'d', '…ñ':'d', '∆ä':'d', '…ó':'d', '∆ã':'d', '∆å':'d', '»°':'d', '√∞':'d',
        '√â':'e', '∆è':'e', '∆é':'e', '«ù':'e', '√©':'e', '√à':'e', '√®':'e', 'ƒî':'e', 'ƒï':'e', '√ä':'e', '√™':'e', '·∫æ':'e', '·∫ø':'e', '·ªÄ':'e', '·ªÅ':'e', '·ªÑ':'e', '·ªÖ':'e', '·ªÇ':'e', '·ªÉ':'e', 'ƒö':'e', 'ƒõ':'e', '√ã':'e', '√´':'e', '·∫º':'e', '·∫Ω':'e', 'ƒñ':'e', 'ƒó':'e', '»®':'e', '»©':'e', '·∏ú':'e', '·∏ù':'e', 'ƒò':'e', 'ƒô':'e', 'ƒí':'e', 'ƒì':'e', '·∏ñ':'e', '·∏ó':'e', '·∏î':'e', '·∏ï':'e', '·∫∫':'e', '·∫ª':'e', '»Ñ':'e', '»Ö':'e', '»Ü':'e', '»á':'e', '·∫∏':'e', '·∫π':'e', '·ªÜ':'e', '·ªá':'e', '·∏ò':'e', '·∏ô':'e', '·∏ö':'e', '·∏õ':'e', '…Ü':'e', '…á':'e', '…ö':'e', '…ù':'e',
        '·∏û':'f', '·∏ü':'f', '·µÆ':'f', '∆ë':'f', '∆í':'f',
        '«¥':'g', '«µ':'g', 'ƒû':'g', 'ƒü':'g', 'ƒú':'g', 'ƒù':'g', '«¶':'g', '«ß':'g', 'ƒ†':'g', 'ƒ°':'g', 'ƒ¢':'g', 'ƒ£':'g', '·∏†':'g', '·∏°':'g', '«§':'g', '«•':'g', '∆ì':'g', '…†':'g',
        'ƒ§':'h', 'ƒ•':'h', '»û':'h', '»ü':'h', '·∏¶':'h', '·∏ß':'h', '·∏¢':'h', '·∏£':'h', '·∏®':'h', '·∏©':'h', '·∏§':'h', '·∏•':'h', '·∏™':'h', '·∏´':'h', 'H':'h', 'Ã±':'h', '·∫ñ':'h', 'ƒ¶':'h', 'ƒß':'h', '‚±ß':'h', '‚±®':'h',
        '√ç':'i', '√≠':'i', '√å':'i', '√¨':'i', 'ƒ¨':'i', 'ƒ≠':'i', '√é':'i', '√Æ':'i', '«è':'i', '«ê':'i', '√è':'i', '√Ø':'i', '·∏Æ':'i', '·∏Ø':'i', 'ƒ®':'i', 'ƒ©':'i', 'ƒ∞':'i', 'i':'i', 'ƒÆ':'i', 'ƒØ':'i', 'ƒ™':'i', 'ƒ´':'i', '·ªà':'i', '·ªâ':'i', '»à':'i', '»â':'i', '»ä':'i', '»ã':'i', '·ªä':'i', '·ªã':'i', '·∏¨':'i', '·∏≠':'i', 'I':'i', 'ƒ±':'i', '∆ó':'i', '…®':'i',
        'ƒ¥':'j', 'ƒµ':'j', 'J':'j', 'Ãå':'j', '«∞':'j', '»∑':'j', '…à':'j', '…â':'j', ' ù':'j', '…ü':'j', ' Ñ':'j',
        '·∏∞':'k', '·∏±':'k', '«®':'k', '«©':'k', 'ƒ∂':'k', 'ƒ∑':'k', '·∏≤':'k', '·∏≥':'k', '·∏¥':'k', '·∏µ':'k', '∆ò':'k', '∆ô':'k', '‚±©':'k', '‚±™':'k',
        'ƒπ':'a', 'ƒ∫':'l', 'ƒΩ':'l', 'ƒæ':'l', 'ƒª':'l', 'ƒº':'l', '·∏∂':'l', '·∏∑':'l', '·∏∏':'l', '·∏π':'l', '·∏º':'l', '·∏Ω':'l', '·∏∫':'l', '·∏ª':'l', '≈Å':'l', '≈Ç':'l', '≈Å':'l', 'Ã£':'l', '≈Ç':'l', 'Ã£':'l', 'ƒø':'l', '≈Ä':'l', '»Ω':'l', '∆ö':'l', '‚±†':'l', '‚±°':'l', '‚±¢':'l', '…´':'l', '…¨':'l', '…≠':'l', '»¥':'l',
        '·∏æ':'m', '·∏ø':'m', '·πÄ':'m', '·πÅ':'m', '·πÇ':'m', '·πÉ':'m', '…±':'m',
        '≈É':'n', '≈Ñ':'n', '«∏':'n', '«π':'n', '≈á':'n', '≈à':'n', '√ë':'n', '√±':'n', '·πÑ':'n', '·πÖ':'n', '≈Ö':'n', '≈Ü':'n', '·πÜ':'n', '·πá':'n', '·πä':'n', '·πã':'n', '·πà':'n', '·πâ':'n', '∆ù':'n', '…≤':'n', '»†':'n', '∆û':'n', '…≥':'n', '»µ':'n', 'N':'n', 'Ãà':'n', 'n':'n', 'Ãà':'n',
        '√ì':'o', '√≥':'o', '√í':'o', '√≤':'o', '≈é':'o', '≈è':'o', '√î':'o', '√¥':'o', '·ªê':'o', '·ªë':'o', '·ªí':'o', '·ªì':'o', '·ªñ':'o', '·ªó':'o', '·ªî':'o', '·ªï':'o', '«ë':'o', '«í':'o', '√ñ':'o', '√∂':'o', '»™':'o', '»´':'o', '≈ê':'o', '≈ë':'o', '√ï':'o', '√µ':'o', '·πå':'o', '·πç':'o', '·πé':'o', '·πè':'o', '»¨':'o', '»≠':'o', '»Æ':'o', '»Ø':'o', '»∞':'o', '»±':'o', '√ò':'o', '√∏':'o', '«æ':'o', '«ø':'o', '«™':'o', '«´':'o', '«¨':'o', '«≠':'o', '≈å':'o', '≈ç':'o', '·πí':'o', '·πì':'o', '·πê':'o', '·πë':'o', '·ªé':'o', '·ªè':'o', '»å':'o', '»ç':'o', '»é':'o', '»è':'o', '∆†':'o', '∆°':'o', '·ªö':'o', '·ªõ':'o', '·ªú':'o', '·ªù':'o', '·ª†':'o', '·ª°':'o', '·ªû':'o', '·ªü':'o', '·ª¢':'o', '·ª£':'o', '·ªå':'o', '·ªç':'o', '·ªò':'o', '·ªô':'o', '∆ü':'o', '…µ':'o',
        '·πî':'p', '·πï':'p', '·πñ':'p', '·πó':'p', '‚±£':'p', '∆§':'p', '∆•':'p', 'P':'p', 'ÃÉ':'p', 'p':'p', 'ÃÉ':'p',
        ' †':'q', '…ä':'q', '…ã':'q',
        '≈î':'r', '≈ï':'r', '≈ò':'r', '≈ô':'r', '·πò':'r', '·πô':'r', '≈ñ':'r', '≈ó':'r', '»ê':'r', '»ë':'r', '»í':'r', '»ì':'r', '·πö':'r', '·πõ':'r', '·πú':'r', '·πù':'r', '·πû':'r', '·πü':'r', '…å':'r', '…ç':'r', '·µ≤':'r', '…º':'r', '‚±§':'r', '…Ω':'r', '…æ':'r', '·µ≥':'r',
        '√ü':'s', '≈ö':'s', '≈õ':'s', '·π§':'s', '·π•':'s', '≈ú':'s', '≈ù':'s', '≈†':'s', '≈°':'s', '·π¶':'s', '·πß':'s', '·π†':'s', '·π°':'s', '·∫õ':'s', '≈û':'s', '≈ü':'s', '·π¢':'s', '·π£':'s', '·π®':'s', '·π©':'s', '»ò':'s', '»ô':'s', ' Ç':'s', 'S':'s', 'Ã©':'s', 's':'s', 'Ã©':'s',
        '√û':'t', '√æ':'t', '≈§':'t', '≈•':'t', 'T':'t', 'Ãà':'t', '·∫ó':'t', '·π™':'t', '·π´':'t', '≈¢':'t', '≈£':'t', '·π¨':'t', '·π≠':'t', '»ö':'t', '»õ':'t', '·π∞':'t', '·π±':'t', '·πÆ':'t', '·πØ':'t', '≈¶':'t', '≈ß':'t', '»æ':'t', '‚±¶':'t', '·µµ':'t', '∆´':'t', '∆¨':'t', '∆≠':'t', '∆Æ':'t', ' à':'t', '»∂':'t',
        '√ö':'u', '√∫':'u', '√ô':'u', '√π':'u', '≈¨':'u', '≈≠':'u', '√õ':'u', '√ª':'u', '«ì':'u', '«î':'u', '≈Æ':'u', '≈Ø':'u', '√ú':'u', '√º':'u', '«ó':'u', '«ò':'u', '«õ':'u', '«ú':'u', '«ô':'u', '«ö':'u', '«ï':'u', '«ñ':'u', '≈∞':'u', '≈±':'u', '≈®':'u', '≈©':'u', '·π∏':'u', '·ππ':'u', '≈≤':'u', '≈≥':'u', '≈™':'u', '≈´':'u', '·π∫':'u', '·πª':'u', '·ª¶':'u', '·ªß':'u', '»î':'u', '»ï':'u', '»ñ':'u', '»ó':'u', '∆Ø':'u', '∆∞':'u', '·ª®':'u', '·ª©':'u', '·ª™':'u', '·ª´':'u', '·ªÆ':'u', '·ªØ':'u', '·ª¨':'u', '·ª≠':'u', '·ª∞':'u', '·ª±':'u', '·ª§':'u', '·ª•':'u', '·π≤':'u', '·π≥':'u', '·π∂':'u', '·π∑':'u', '·π¥':'u', '·πµ':'u', '…Ñ':'u', ' â':'u',
        '·πº':'v', '·πΩ':'v', '·πæ':'v', '·πø':'v', '∆≤':'v', ' ã':'v',
        '·∫Ç':'w', '·∫É':'w', '·∫Ä':'w', '·∫Å':'w', '≈¥':'w', '≈µ':'w', 'W':'w', 'Ãä':'w', '·∫ò':'w', '·∫Ñ':'w', '·∫Ö':'w', '·∫Ü':'w', '·∫á':'w', '·∫à':'w', '·∫â':'w',
        '·∫å':'x', '·∫ç':'x', '·∫ä':'x', '·∫ã':'x',
        '√ù':'y', '√Ω':'y', '·ª≤':'y', '·ª≥':'y', '≈∂':'y', '≈∑':'y', 'Y':'y', 'Ãä':'y', '·∫ô':'y', '≈∏':'y', '√ø':'y', '·ª∏':'y', '·ªπ':'y', '·∫é':'y', '·∫è':'y', '»≤':'y', '»≥':'y', '·ª∂':'y', '·ª∑':'y', '·ª¥':'y', '·ªµ':'y', ' è':'y', '…é':'y', '…è':'y', '∆≥':'y', '∆¥':'y',
        '≈π':'z', '≈∫':'z', '·∫ê':'z', '·∫ë':'z', '≈Ω':'z', '≈æ':'z', '≈ª':'z', '≈º':'z', '·∫í':'z', '·∫ì':'z', '·∫î':'z', '·∫ï':'z', '∆µ':'z', '∆∂':'z', '»§':'z', '»•':'z', ' ê':'z', ' ë':'z', '‚±´':'z', '‚±¨':'z', '«Æ':'z', '«Ø':'z', '∆∫':'z',
        // Roman fullwidth ascii equivalents: 0xff00 to 0xff5e
        'Ôºí':'2', 'Ôºñ':'6', 'Ôº¢':'B', 'Ôº¶':'F', 'Ôº™':'J', 'ÔºÆ':'N', 'Ôº≤':'R', 'Ôº∂':'V', 'Ôº∫':'Z', 'ÔΩÇ':'b', 'ÔΩÜ':'f', 'ÔΩä':'j', 'ÔΩé':'n', 'ÔΩí':'r', 'ÔΩñ':'v', 'ÔΩö':'z', 'Ôºë':'1', 'Ôºï':'5', 'Ôºô':'9', 'Ôº°':'A', 'Ôº•':'E', 'Ôº©':'I', 'Ôº≠':'M', 'Ôº±':'Q', 'Ôºµ':'U', 'Ôºπ':'Y', 'ÔΩÅ':'a', 'ÔΩÖ':'e', 'ÔΩâ':'i', 'ÔΩç':'m', 'ÔΩë':'q', 'ÔΩï':'u', 'ÔΩô':'y', 'Ôºê':'0', 'Ôºî':'4', 'Ôºò':'8', 'Ôº§':'D', 'Ôº®':'H', 'Ôº¨':'L', 'Ôº∞':'P', 'Ôº¥':'T', 'Ôº∏':'X', 'ÔΩÑ':'d', 'ÔΩà':'h', 'ÔΩå':'l', 'ÔΩê':'p', 'ÔΩî':'t', 'ÔΩò':'x', 'Ôºì':'3', 'Ôºó':'7', 'Ôº£':'C', 'Ôºß':'G', 'Ôº´':'K', 'ÔºØ':'O', 'Ôº≥':'S', 'Ôº∑':'W', 'ÔΩÉ':'c', 'ÔΩá':'g', 'ÔΩã':'k', 'ÔΩè':'o', 'ÔΩì':'s', 'ÔΩó':'w'
    };

    var ret = '';
    for (var i = 0; i < str.length; i++) {
        ret += accent_map[str.charAt(i)] || str.charAt(i);
    }
    return ret;

};

// Bring browser focus to the specified object.
// Use of setTimeout is to get around an IE bug.
// (See, e.g., http://stackoverflow.com/questions/2600186/focus-doesnt-work-in-ie)
//
// obj: a jQuery object to focus()
function focus_with_timeout(obj) {
    setTimeout(function() { obj.focus(); }, 50);
}

// Really basic cache for the results
$.TokenList.Cache = function (options) {
    var settings = $.extend({
        max_size: 500
    }, options);

    var data = {};
    var size = 0;

    var flush = function () {
        data = {};
        size = 0;
    };

    this.add = function (query, results) {
        if(size > settings.max_size) {
            flush();
        }

        if(!data[query]) {
            size += 1;
        }

        data[query] = results;
    };

    this.get = function (query) {
        return data[query];
    };
};
}(jQuery));
